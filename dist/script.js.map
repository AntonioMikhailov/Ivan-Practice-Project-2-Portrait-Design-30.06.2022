{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/main.js","webpack:///./src/js/modules/accordeon.js","webpack:///./src/js/modules/burger.js","webpack:///./src/js/modules/calc.js","webpack:///./src/js/modules/checkTextInputs.js","webpack:///./src/js/modules/drop.js","webpack:///./src/js/modules/filter.js","webpack:///./src/js/modules/forms.js","webpack:///./src/js/modules/mask.js","webpack:///./src/js/modules/modals.js","webpack:///./src/js/modules/pictureSize.js","webpack:///./src/js/modules/scrolling.js","webpack:///./src/js/modules/showMoreStyles.js","webpack:///./src/js/modules/sliders.js","webpack:///./src/js/services/requests.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACE;AACJ;AACF;AACsB;AACF;AACtB;AACI;AACW;AACL;AACN;AACM;AACV;;;AAGlC,kD;AACA;;AAEA;AACA,CAAC,+DAAM;;AAEP;AACA,CAAC,gEAAO;AACR;AACA,EAAE,gEAAO;AACT,EAAE,8DAAK;AACP,EAAE,6DAAI;;AAEN;AACA,EAAE,wEAAe;AACjB,EAAE,wEAAe;AACjB,mDAAmD;AACnD,CAAC,uEAAc,mCAAmC;AAClD,6DAAI;AACJ,+DAAM;AACN,oEAAW;AACX;AACA;AACA,kEAAS,uB;AACT,gEAAM;AACN,mEAAS;AACT,8DAAI;;;;AAIJ,CAAC,EAAE,gB;;;;;;;;;;;;AC7CH;AAAA;AACA;;AAEA;;AAEA,6BAA6B;AAC7B;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN,IAAI;AACJ;;;AAGA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA,kGAAkG;AAClG,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,gDAAgD;AAChD;AACA,+C;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gGAAgG;;;AAGhG;;AAEA,OAAO;AACP;AACA;AACA,MAAM;AACN,IAAI;;AAEJ,EAAE;AACa,wEAAS,E;;;;;;;;;;;;ACnExB;AAAA;AACA;AACA;;AAEA,gCAAgC;;AAEhC,2C;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,CAAC;;AAED;AACA,wC;AACA;AACA;AACA,E;AACA,CAAC;;AAED,EAAE;AACa,qEAAM,E;;;;;;;;;;;;ACtBrB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACa,mEAAI,E;;;;;;;;;;;;ACxCnB;AAAA;AACA,yD;;AAEA,8B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,O;;AAEA,CAAC,E;AACD;AACA;AACA;AACA,CAAC;AACD,IAAI;AACJ;;AAEe,8EAAe,EAAC,6B;;;;;;;;;;;;ACpB/B;AAAA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D;AAC3D,EAAE;AACF,CAAC;;AAED;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA,8DAA8D;AAC9D,GAAG;AACH,mE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,MAAM;AACN,KAAK;;AAEL;AACA;AACA;AACA;AACA,uEAAuE;AACvE,MAAM;AACN,KAAK;;AAEL;AACA;AACA,2C;AACA;AACA,0CAA0C;AAC1C;AACA,iBAAiB;AACjB;AACA,0EAA0E;AAC1E;AACA;AACA;;AAEA,OAAO,GAAG;AACV,MAAM;;AAEN,EAAE;;AAEa,mEAAI,E;;;;;;;;;;;;ACpEnB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,EAAE;AACF;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;AACA,uC;AACA;AACA,CAAC;AACD,0C;AACA;AACA,CAAC;AACD,wC;AACA;AACA,CAAC;AACD,wC;AACA;AACA,CAAC;AACD,uC;AACA;AACA,CAAC;AACD,+C;AACA;AACA,CAAC;AACD,4C;AACA;AACA,CAAC;;AAED;AACA,sC;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;;AAEA,CAAC;;AAED,EAAE;AACa,qEAAM,EAAC;;;;;;;;;;;;;AClFtB;AAAA;AAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,wB;AACA,kB;AACA,EAAE;AACF;AACA,yB;AACA;AACA,EAAE;AACF;AACA;AACA,wB;AACA,uC;AACA;AACA,6BAA6B;AAC7B,kCAAkC;AAClC,WAAW;AACX;AACA,0EAA0E;;AAE1E;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C,EAAE;AACF,EAAE;;AAEF;AACA,sB;AACA,yC;AACA,uBAAuB;AACvB;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,mEAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA,KAAK;AACL;AACA;AACA,mBAAmB;AACnB;AACA,8BAA8B;AAC9B,qCAAqC;AACrC,2CAA2C;AAC3C,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA,yD;AACA;AACA,YAAY;;AAEZ,OAAO;AACP,KAAK;AACL,EAAE;AACF,EAAE;;;AAGF,EAAE;;AAEa,oEAAK,EAAC;;;;;;;;;;;;;;;AC3IrB;AAAA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,GAAG,iCAAiC;AACpC;;AAEA,yBAAyB;AACzB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gD;AACA;AACA;AACA,wFAAwF;AACxF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;;AAGA;;;AAGA;;AAEA;AACA,wB;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF,EAAE;;AAEa,mEAAI,E;;;;;;;;;;;;;;ACtEnB;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA,qF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG,KAAK;AACR;;AAEA;AACA;AACA,2B;AACA,wC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;;AAEA,IAAI,E;AACJ,EAAE;;AAEF;AACA,sC;AACA;AACA;AACA;;AAEA,IAAI;AACJ,aAAa;AACb;;;AAGA,EAAE;AACF;AACA,0C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,IAAI;;AAEJ,EAAE;;;AAGF;AACA,sDAAsD;AACtD,mCAAmC;AACnC;;AAEA;AACA,sC;AACA,2C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,4C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iDAAiD;;;AAGjD;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,EAAE;AACa,qEAAM,EAAC,6B;;;;;;;;;;;;ACpJtB;AAAA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,2C;AACA;AACA,GAAG;;AAEH,0C;AACA;AACA,GAAG;AACH,CAAC;;;AAGD,EAAE;AACa,0EAAW,E;;;;;;;;;;;;ACtC1B;AAAA;;AAEA;AACA;AACA,0C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,kCAAkC;AAClC,+BAA+B;;AAE/B;;AAEA,uDAAuD;AACvD;;AAEA;AACA,8C;AACA;AACA,sDAAsD;;AAEtD,0BAA0B;AAC1B,sBAAsB;;AAEtB,2EAA2E;AAC3E,yBAAyB;AACzB;;AAEA,gCAAgC;;AAEhC;AACA,0BAA0B;AAC1B,uBAAuB;AACvB;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA,KAAK;AACL;AACA;;AAEA,KAAK;;AAEL,GAAG;AACH,CAAC;;;;AAID;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,qEAAqE;;;AAGrE,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,+B;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;;AAEA,IAAI;AACJ;;AAEA,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,qE;;AAEA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;;AAEA,MAAM;AACN,+BAA+B;AAC/B,kCAAkC;AAClC,iCAAiC;AACjC;;AAEA,IAAI;AACJ;;;AAGA;;;;;;AAMA,EAAE;AACa,wEAAS,E;;;;;;;;;;;;AChJxB;AAAA;AAAmD;;AAEnD,+C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,uC;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB;AACpB,IAAI;;AAEJ;AACA,6C;;AAEA;;AAEA,0C;AACA;AACA,EAAE,sEAAW;AACb;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED,gCAAgC;AAChC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,QAAQ,MAAM;AACd,aAAa,KAAK;AAClB;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;AACA,EAAE;AACa,6EAAc,E;;;;;;;;;;;;AC1D7B;AAAA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,wB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yB;AACA,mCAAmC;AACnC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,0C;AACA,oBAAoB;AACpB,yDAAyD;AACzD;AACA,GAAG;AACH,yC;AACA,kBAAkB;AAClB,0DAA0D;AAC1D;AACA,GAAG;AACH,CAAC;AACD;AACA,mBAAmB;AACnB;AACA,8B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,GAAG;AACH,CAAC,OAAO;AACR,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB,CAAC;AACD;AACA;AACA,wBAAwB;AACxB,GAAG;;;AAGH,EAAE;AACa,sEAAO,E;;;;;;;;;;;;ACrEtB;AAAA;AAAA;AAAA;;AAEA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,yCAAyC,IAAI,WAAW,WAAW;AACnE;AACA;AACA;AACA;;AAEA;AACA,E","file":"script.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/main.js\");\n","import  modals  from \"./modules/modals\";\r\nimport  sliders  from \"./modules/sliders\";\r\nimport  forms  from \"./modules/forms\";\r\nimport  mask  from \"./modules/mask\";\r\nimport  checkTextInputs  from \"./modules/checkTextInputs\";\r\nimport  showMoreStyles  from \"./modules/showMoreStyles\";\r\nimport calc from \"./modules/calc\";\r\nimport filter from \"./modules/filter\";\r\nimport  pictureSize from \"./modules/pictureSize\";\r\nimport accordeon from \"./modules/accordeon\";\r\nimport burger from \"./modules/burger\";\r\nimport scrolling from \"./modules/scrolling\";\r\nimport drop from \"./modules/drop\";\r\n\r\n\r\nwindow.addEventListener('DOMContentLoaded', ()=> { \r\n  'use strict';\r\n\r\n  //вызываем модули\r\n modals();\r\n\r\n //сначала запускаем слайдер с кнопками - dir пока не используем\r\n sliders('.feedback-slider-item', '', '.main-prev-btn', '.main-next-btn');\r\n  //запускаем первый слайдер без кнопок вертикальный + dir\r\n  sliders('.main-slider-item', 'vertical');\r\n  forms();\r\n  mask('[name=\"phone\"]');\r\n\r\n  //имена получаем и пле message\r\n  checkTextInputs('[name = \"name\"]');\r\n  checkTextInputs('[name = \"message\"]');\r\n  // showMoreStyles('.button-styles', '.styles-2'); // для первого варианта\r\n showMoreStyles('.button-styles', '#styles .row'); // для варианта с сервером через родитель \r\ncalc('#size', '#material', '#options', '.promocode', '.calc-price');\r\nfilter();\r\npictureSize('.sizes-block');\r\n// accordeon('.accordion-heading', '.accordion-block')// первый вариант\r\n//второй вариант\r\naccordeon('.accordion-heading'); \r\nburger('.burger-menu', '.burger');\r\nscrolling('.pageup');\r\ndrop();\r\n\r\n\r\n \r\n}); // конец loaded","const accordeon = (triggersSelector )=> {\r\n  const btns = document.querySelectorAll(triggersSelector);\r\n\r\n  // Первый вариант на CSS свойствах\r\n\r\n//   blocks.forEach(item => { // добавим анимацию для контента при появлении\r\n//     item.classList.add('animated', 'fadeInDown');\r\n// });\r\n\r\n// btns.forEach(item => {\r\n//   item.addEventListener('click', function() {\r\n//     console.log(333);\r\n//     // обычная ф. т.к. this \r\n//     //узнаем  - является ли элемент на котором кликнули активным \r\n//    if(!this.classList.contains('active')) {\r\n//     //если нет\r\n  \r\n//    btns.forEach(elem => {\r\n//   elem.classList.remove('active', 'active-style')\r\n//    });\r\n//    this.classList.add('active', 'active-style');\r\n//    }\r\n//   });\r\n// });\r\n// // Показ и скрытие самого контента делаем в main.css\r\n\r\n\r\n  // //ВТОРОЙ вариант на JS  - меняем высоту блоков конента - открыть можно все элементы\r\n  btns.forEach(item => {\r\n    item.addEventListener('click', function() { // нужен контекст вызова поэтому обычная ф.\r\n    this.classList.toggle('active-style');\r\n    //далее класс active добавляем уже контенту - следующему после кнопки триггера\r\n    this.nextElementSibling.classList.toggle('active-content');\r\n\r\n    if(this.classList.contains('active-style')) {\r\n      this.nextElementSibling.style.maxHeight =  this.nextElementSibling.scrollHeight + 80 + 'px'; // 80 это padding в стилях\r\n    } else {\r\n      this.nextElementSibling.style.maxHeight =  '0px';\r\n    }\r\n    });\r\n  });\r\n\r\n  //ТРЕТИЙ вариант - открыть можно только по одному элементу\r\n// btns.forEach(item => {\r\n//   item.addEventListener('click', function() { // нужен контекст вызова поэтому обычная ф.\r\n//     btns.forEach(elem => {\r\n//       elem.classList.remove('active-style');      \r\n//     });\r\n//    this.classList.add('active-style');\r\n//    //далее класс active добавляем уже контенту - следующему после кнопки триггера\r\n//    this.nextElementSibling.forEach(element => {\r\n//     element.classList.remove('active-content');\r\n//   element.style.maxHeight =  '0px';\r\n// });\r\n// this.nextElementSibling.classList.add('active-content');\r\n//  this.nextElementSibling.style.maxHeight =  this.nextElementSibling.scrollHeight + 80 + 'px'; // 80 это padding в стилях\r\n\r\n\r\n  //  if(this.classList.contains('active-style')) {\r\n   \r\n  //  } else {\r\n  //   this.nextElementSibling.style.maxHeight =  '0px';\r\n  //  }\r\n  // });\r\n// });\r\n\r\n}; //\r\nexport default accordeon;","const burger = (menuSelector, burgerSelector)=> {\r\nconst menuElem = document.querySelector(menuSelector);\r\nconst burgerElem = document.querySelector(burgerSelector);\r\n\r\nmenuElem.style.display = 'none'; // делаем изначально скрытым\r\n\r\nburgerElem.addEventListener('click', ()=> { \r\n if(menuElem.style.display == 'none' && window.screen.availWidth < 993) {\r\n  menuElem.style.display = 'block';\r\n } else {\r\n  menuElem.style.display = 'none';\r\n }\r\n});\r\n\r\n// следим за шириной экрана\r\nwindow.addEventListener('resize', ()=> { \r\n if(window.screen.availWidth > 992) {\r\n  menuElem.style.display = 'none';\r\n } \r\n});\r\n\r\n}; //\r\nexport default burger;","//передаем в параметры\r\nconst calc = (size, material, options, promocode, result )=> {\r\n  const sizeBlock = document.querySelector(size);\r\n  const materialBlock = document.querySelector(material);\r\n  const optionsBlock = document.querySelector(options);\r\n  const promocodeBlock = document.querySelector(promocode);\r\n  const resultBlock = document.querySelector(result);\r\n  \r\n\r\nlet sum = 0;\r\n//вешаем обработчик change + ф. которая будет срабатывать на нем\r\nconst calcFunction = ()=> {\r\nsum = Math.round((+sizeBlock.value) * (+materialBlock.value) + (+optionsBlock.value));\r\n// sum = 1000;\r\n\r\n//обязательны к заполнению первые 2 селекта поэтому делаем проверку на пустое value - которое мы поставили в верстке самым первым = если оно есть, значит юзер не сделал выбор \r\nif(sizeBlock.value == '' || materialBlock.value == '' ) {\r\n  // то выводим сообщение\r\nresultBlock.textContent = 'Пожалуйста выберите размер и материал';\r\n\r\n} else if (promocodeBlock.value =='IWANTPOPART ') {\r\n  //проверяем промокод IWANTPOPART  - который можно получить при клике на подарок\r\n  //тогда делаем скидку 30%\r\n  resultBlock.textContent = Math.round( sum * 0.7);\r\n}\r\n//но если без промокода - просто else\r\nelse {\r\n  resultBlock.textContent = sum;\r\n}\r\n\r\n};\r\n\r\n//запускаем обработчики для каждого поля\r\nsizeBlock.addEventListener('change', calcFunction);\r\nmaterialBlock.addEventListener('change', calcFunction);\r\noptionsBlock.addEventListener('change', calcFunction);\r\npromocodeBlock.addEventListener('change', calcFunction);\r\n// console.log(sum);\r\n\r\n}; // конец\r\nexport default calc;","const checkTextInputs = (selector)=> {\r\n  const textInputs = document.querySelectorAll(selector); \r\n\r\n  textInputs.forEach(item => { \r\n    item.addEventListener('keypress', (e)=> {\r\n     //получаем кнопку которую нажал юзер\r\n      if(e.key.match(/[^а-яё 0-9]/ig)){\r\n        // ^ - исключающий диапазон - значит все кроме этих и значит вся латиница будет preventDefault\r\n        // будет отображать только  - если вся кириллица + цифры в любом регистре\r\n        e.preventDefault(); //Работает , но не понял.  Отменил стандартное поведение чего? Ввод остальных символов видимо. Понял см. выше.\r\n      } \r\n   \r\n}); \r\n//я создал второй обработчик - и он работает даже проще чем выше у Ивана. Он также стирает те данные которые можно вставить в поле через копирование на латинице или которые есть в автозаполнении. Т.е. достаточно этого обработчика - я\r\nitem.addEventListener('input', ()=> {\r\n  item.value =  item.value.replace(/[a-z]/ig, '');\r\n});\r\n   });\r\n};\r\n\r\nexport default checkTextInputs; // по умолчанию экспортируем","const drop = () => {\r\n\r\nconst fileInputs = document.querySelectorAll('[name=\"upload\"]');\r\n// на эти input нам надо повесить 4 разных события - можно через цикл 4 раза назначить 4 разных события, но  можно по другому - создать массив событий\r\n\r\n['dragenter', 'dargleave', 'dragover', 'drop'].forEach(eventName => {\r\n//внутри еще один цикл\r\nfileInputs.forEach(item => {\r\n  item.addEventListener(eventName, preventDefaults, false);   // обработчик будет приходить из внешнего цикла\r\n });\r\n});\r\n\r\nfunction preventDefaults(e) {\r\n  e.preventDefault();\r\n  e.stopPropagation(); //Прекращает дальнейшую передачу текущего события. прекращает всплытие события выше к родителям\r\n\r\n}\r\n// подскажем юзеру что его фото над нужно областью загрузки\r\nfunction highLight(item) { // подсветиv Ближайший к форме блок file-upload\r\nitem.closest('.file_upload').style.backgroundColor = \"blue\";\r\nconsole.log(444);\r\n\r\n}\r\n// убираем подсветку после события\r\nfunction unHighLight(item) { //\r\n\r\n  if(item.closest('.calc_form')) {\r\n  item.closest('.file_upload').style.backgroundColor = \"#fff\"; // но цвет фона может быть разный у разных форм поэтому делаем проверку на фон родителя\r\n  } else {\r\n    item.closest('.file_upload').style.backgroundColor = \"#ededed\"; \r\n  }\r\n  \r\n  }\r\n\r\n// ловим событие когда фото над зоной drop\r\n  ['dragenter',  'dragover'].forEach(eventName => {\r\n    //внутри еще один цикл\r\n    fileInputs.forEach(item => {\r\n      item.addEventListener( eventName, ()=> highLight(item), false);   // обработчик будет приходить из внешнего цикла\r\n     });\r\n    });\r\n\r\n    // наоборот -ловим событие когда фото уходит из зоны drop \r\n  ['dragleave',  'drop'].forEach(eventName => {\r\n    //внутри еще один цикл\r\n    fileInputs.forEach(item => {\r\n      item.addEventListener( eventName, ()=> unHighLight(item), false);   // \r\n     });\r\n    });\r\n\r\n    //теперь ловим событие drop\r\n    fileInputs.forEach(item => {\r\n      item.addEventListener('drop', (e)=> { \r\n        // получаем и модифицируем файлы 15-24\r\n        item.files = e.dataTransfer.files; //кладем в input объект с файлом из проводника\r\n        // также как и в forms.js обрезаем длинные имена фото - копируем код от туда\r\n        let dots; // троеточие\r\n  //получаем имя файла в разметку HTML\r\n  item.files[0].name.split('.')[0].length > 5 ? dots = \"...\" : dots = '.'; // разбиваем точкой на массив, проверяем на длину и создаем условие для dots\r\n  //имя  - первая часть обрезаем  slice + троеточие + вторая часть\r\n  const name =  item.files[0].name.split('.')[0].slice(0, 6) + dots + item.files[0].name.split('.')[1];\r\n  item.previousElementSibling.textContent =  name;\r\n\r\n      } );   // обработчик будет приходить из внешнего цикла\r\n     });\r\n\r\n};//\r\n\r\nexport default drop;","const filter = ()=> {\r\n  // т.к. классов в весртке очень много передавать их в параметры мы не будем т.к. нерационально - пропишем их вручную\r\nconst menu = document.querySelector('.portfolio-menu');\r\nconst items = menu.querySelectorAll('li');\r\nconst btnAll = menu.querySelector('.all');\r\nconst btnLovers = menu.querySelector('.lovers');\r\nconst btnChef = menu.querySelector('.chef');\r\nconst btnGirl = menu.querySelector('.girl');\r\nconst btnGuy = menu.querySelector('.guy');\r\nconst btnGrandmother = menu.querySelector('.grandmother');\r\nconst btnGranddad = menu.querySelector('.granddad');\r\n\r\nconst wrapper = document.querySelector('.portfolio-wrapper');\r\nconst markGirl = wrapper.querySelectorAll('.girl');\r\nconst markAll = wrapper.querySelectorAll('.all');\r\nconst markLovers = wrapper.querySelectorAll('.lovers');\r\nconst markChef = wrapper.querySelectorAll('.chef');\r\nconst markGuy = wrapper.querySelectorAll('.guy');\r\nconst no = document.querySelector('.portfolio-no');\r\n\r\n\r\n//создадим ф. фильтрации элементов\r\nconst typeFilter = (markType)=> {\r\n  //сначала скрываем все элементы\r\n markAll.forEach(item => {\r\n  item.style.display = 'none';\r\n  item.classList.remove('animated', 'fadeIn'); // из animate.css\r\n });\r\n no.style.display = 'none';\r\n no.classList.remove('animated', 'fadeIn');\r\n\r\nif(markType) { // если есть данные в параметре\r\n  markType.forEach(item => {\r\n    item.style.display = 'block';\r\n    item.classList.add('animated', 'fadeIn');\r\n  });\r\n  //если в параметр ничего не передали - значит фото для бабушек и дедушек и показываем текст - что таких фото пока нет\r\n} else {\r\n  no.style.display = 'block';\r\n  no.classList.add('animated', 'fadeIn');\r\n \r\n}\r\n\r\n};\r\n\r\n//эти вызовы после клика можно оптимизировать  - как?  12-19\r\nbtnAll.addEventListener('click', ()=> { \r\n  typeFilter(markAll)\r\n});\r\nbtnLovers.addEventListener('click', ()=> { \r\n  typeFilter(markLovers)\r\n});\r\nbtnChef.addEventListener('click', ()=> { \r\n  typeFilter(markChef)\r\n});\r\nbtnGirl.addEventListener('click', ()=> { \r\n  typeFilter(markGirl)\r\n});\r\nbtnGuy.addEventListener('click', ()=> { \r\n  typeFilter(markGuy)\r\n});\r\nbtnGrandmother.addEventListener('click', ()=> { \r\n  typeFilter() // без аргументов т.к еще нет таких фото\r\n});\r\nbtnGranddad.addEventListener('click', ()=> { \r\n  typeFilter()  // без аргументов т.к еще нет таких фото\r\n});\r\n\r\n// делаем подсветку активного таба через делегирование\r\nmenu.addEventListener('click', (e)=> { \r\nlet target = e.target;\r\nif(target && target.tagName == 'LI') {\r\n items.forEach(elem => {\r\n  elem.classList.remove('active');\r\n  target.classList.add('active')\r\n  \r\n });\r\n}\r\n \r\n});\r\n\r\n}; //конец\r\nexport default filter;\r\n","import {postData} from \"../services/requests\";\r\n\r\nconst forms = ()=> {\r\n//получаем все формы и все input\r\nconst form = document.querySelectorAll('form');\r\nconst inputs = document.querySelectorAll('input');\r\n//для загрузки фото - все input  с этим атрибутом\r\nlet upload = document.querySelectorAll('[name = \"upload\"]');\r\n\r\n\r\n//оповещаем юзера о процессе отправки - создадим объект с текстами\r\nconst message = {\r\nloading: 'Загрузка',\r\nsuccess: 'Спасибо, мы скоро с Вами свяжемся',\r\nfailure: 'Что то пошло не так...',\r\n// покажем перед отправкой иконки\r\nspinner: \"assets/img/spinner.gif\", \r\nok: \"assets/img/ok.png\",\r\nfail: \"assets/img/fail.png\",\r\n};\r\n\r\n//настроим пути для отправки данных – они у нас разные\r\nconst path = {\r\n  designer: 'assets/server.php', // для фото\r\n  question: 'assets/question.php', // для вопросов\r\n};\r\n\r\n//ф. отправки\r\n\r\n\r\n//доп. ф по очистке input\r\nconst clearInput = ()=> {\r\ninputs.forEach(item => { \r\n  item.value = ''; \r\n });\r\n //Добавляем очистку имени - файл не выбран\r\n upload.forEach(item => { \r\n  item.previousElementSibling.textContent =  'Файл не выбран';\r\n });\r\n};\r\n//для фото - обработчик - сработает когда юзер добавит фото\r\nupload.forEach(item => { \r\n  item.addEventListener('input', ()=> { \r\n    //получаем имя файла фото через свойство files\r\n  console.log(item.files[0]); // вся инфа\r\n  console.log(item.files[0].name); // Готовый сайт-29.06.png\r\n  let dots; // троеточие\r\n  //получаем имя файла в разметку HTML\r\n  item.files[0].name.split('.')[0].length > 5 ? dots = \"...\" : dots = '.'; // разбиваем точкой на массив, проверяем на длину и создаем условие для dots\r\n\r\n  //имя  - первая часть обрезаем  slice + троеточие + вторая часть\r\n  const name =  item.files[0].name.split('.')[0].slice(0, 6) + dots + item.files[0].name.split('.')[1];\r\n  item.previousElementSibling.textContent =  name;\r\n\r\n  //можно оптимизировать код\r\n  //let arr = item.files[0].name.split('.'); // и заменить выше.\r\n });\r\n });\r\n\r\n//навешиваем обработчики на клики по отправке формы\r\nform.forEach(item => { \r\n  item.addEventListener('submit', (e)=> { \r\n    e.preventDefault(); // убираем перезагрузку страницы\r\n    //подготавливаем форму - для показа сообщений о процессе отправки\r\n    let statusMessage = document.createElement('div');\r\n    statusMessage.classList.add('status');\r\n    item.parentNode.appendChild(statusMessage); //родитель формы\r\n\r\n    //добавляем классы из animate.css\r\n    item.classList.add('animated', 'fadeOutUp'); // скрываем - из animate.css\r\n    //т.к. форма не исчезнет из структуры а просто станет прозрачной она не даст иконкам появиться в нужном месте поэтому надо форму после анимации совсем убрать из структуры\r\n    setTimeout(() => {\r\n      item.style.display = 'none';\r\n    }, 400); // примерно\r\n//создаем элемент для иконок\r\n    let statusImg = document.createElement('img');\r\n    statusImg.setAttribute('src', message.spinner );\r\n    //добавим анимацию\r\n    statusImg.classList.add('animated', 'fadeInUp');\r\n    //вставляем фото в блок родителя формы\r\n    statusMessage.appendChild(statusImg);\r\n\r\n    //также еще добавим текст к иконке\r\n    let textMessage = document.createElement('div');\r\n    textMessage.textContent = message.loading;\r\n    //добавлем\r\n    statusMessage.appendChild(textMessage);\r\n\r\n  //собираем все данные из формы с formData c помощью конструктора FormData ( если нужен формат JSON то надо сконвертировать)\r\n    const formData = new FormData(item); // из какой формы получать\r\n    //api - нужен для формирования динамического пути отправки\r\nlet api ;\r\n// если в родителях не найдет -вернет null (false), если найдет -то сработает путь designer\r\n//Если условий будет больше - использовать switch-case\r\n item.closest('.popup-design') || item.classList.contains('calc_form')  ? api = path.designer : api = path.question;\r\nconsole.log(api);\r\n\r\n    // вызываем ф. и передаем путь api и данные формы\r\n    postData(api, formData)\r\n    //далее получаем ответ в виде текста\r\n    .then(res => {\r\n      console.log(res);\r\n      //если успешно прошел запрос пишем сообщение юзеру\r\n      statusImg.setAttribute('src', message.ok );\r\n      textMessage.textContent = message.success;\r\n    })\r\n    //если будет ошибка то catch\r\n    .catch( ()=> {\r\n      statusImg.setAttribute('src', message.fail );\r\n      textMessage.textContent = message.failure;\r\n      \r\n     \r\n    })\r\n    //finally для очистки полей и скрытия сообщения об отправке\r\n    .finally(() => {\r\n      clearInput(); // вызвали ф. очистки полей\r\n      setTimeout(() => {\r\n       statusMessage.remove(); //просто удаляем элемент через таймер\r\n        item.style.display = 'block'; // показываем форму обратно\r\n        item.classList.remove('fadeOutUp'); // удаляем класс показа\r\n        item.classList.add('fadeInUp'); // добавим класс анимации показа\r\n\r\n        // закрываем все модалки после кнопки Отправить\r\n        // const windows = document.querySelectorAll('[data-modal]');\r\n        // windows.forEach(item => {\r\n        //   item.style.visibility = 'hidden';\r\n        //   item.style.opacity = 0;\r\n        //   item.style.transition = 'all 0.7s ease .0s'; \r\n        //    document.body.style.overflow = '';\r\n        // });\r\n\r\n      }, 3000);\r\n    });\r\n });\r\n });\r\n\r\n\r\n}; //конец forms\r\n\r\nexport default forms; // по умолчанию экспортируем\r\n\r\n\r\n","const mask = (selector)=> { // в параметр будем передавать нужны input для валидации\r\n\r\nlet setCursorPosition = (pos, elem) => {\r\n  //сначала установим фокус\r\n  elem.focus();\r\n  // далее нужен метод setSelectionRange - но он не поддерживается старыми бр. и нам надо написать полифил\r\n  if(elem.setSelectionRange) {\r\n    elem.setSelectionRange(pos, pos); // установим курсор\r\n  } else if (elem.createTextRange) { // если не поддерживает то метод range\r\n    let range = elem.createTextRange();\r\n\r\n    range.collapse(true);  // объединит граничные точки диапазона  \r\n    range.moveStart('character', pos);\r\n    range.moveEnd('character', pos);\r\n    range.select();\r\n\r\n  }\r\n\r\n};\r\n\r\nfunction createMask(event) {\r\n  // создаем матрицу  - можно в JSON  файле для рая разных стран - она будет в input видна\r\n  let matrix = '+7 (___) ___ __ __';\r\n  //итератор\r\nlet  i = 0;\r\n//получаем все Нецифры  и заменяем пустым - на основе матрицы\r\nlet def = matrix.replace(/\\D/g, '');\r\n// все Нецифры чистим  - на основе ввода юзера\r\nlet val = this.value.replace(/\\D/g, '' );\r\n\r\n//сверяем кол. во симвлов. Если юзер начнет удалаять из матрицы +7 то он не сможет это сделать\r\nif(def.length >= val.length) {\r\n  val = def;\r\n}\r\n//нам надо из матрицы удалить нижнее подчеркивание в процессе вода цифр - заменить на цифры, но скобки оставляем и пробелы между группами цифр\r\n//в метод replace мы  аожем передать и ф.\r\nthis.value = matrix.replace(/./g, function (a) { \r\n  //проверяем символы на правильность\r\n  //Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, то возвращает true , иначе false \r\n return /[_\\d]/.test(a) && i < val.length ? val.charAt(i++) : i >= val.length ? '' : a ; //  a - каждый символ который перебирается в матрице и проверяем что длина уже введенных и очищенных символов будет не больше чем в val - и если true то переходим к следующему символу и если второе условие false то вернем пустая строка а если  и оно False то просто - a ( тот же символ что и пришел в ф.)\r\n});\r\n\r\n// еще одно условие когда выделяем input  c маской то курсор должен встать в определенную позицию - после +7 ( сюда) и потом если он выйдет из Input - blur то маска должна снова восстановиться\r\nif(event.type == 'blur') {\r\n  //если кол-во символов будет равно 2 (+7) то очистим input\r\n  if(this.value.length == 2) {\r\n    this.value = '';\r\n  }\r\n}  else {\r\n  //куда установить курсор - вызываем ф.\r\n  setCursorPosition(this.value.length, this);\r\n  console.log(this.value.length);\r\n  console.log(this);\r\n\r\n\r\n}\r\n\r\n \r\n}\r\n\r\nlet inputs = document.querySelectorAll(selector);\r\ninputs.forEach(item => { \r\n //обрабатываем все \r\n  item.addEventListener('input', createMask );\r\n  item.addEventListener('focus', createMask );\r\n  item.addEventListener('blur', createMask );\r\n \r\n });\r\n\r\n}; // конец\r\n\r\nexport default mask;","\r\nconst modals =()=> {\r\n\r\n  //создадим перем. которая следит была ли нажата какая то из кнопок триггеров - нужно для п13 отследить подарок\r\n  let btnPressed = false;\r\n  //теперь если эзер кликнет по какойто кнопке вызова модалки она станет true\r\n\r\n\r\n  // первым аргументом сама кнопка , вторым какое окно открывать, + селектор который будет закрывать это окно\r\n  const windows = document.querySelectorAll('[data-modal]');\r\n\r\n   //Убираем сдвиг контента при модалке\r\n   //получаем ширину полосы прокрутки\r\n   const innerWidth = window.innerWidth;\r\n    const outerWidth = document.body.clientWidth;\r\n    const contentShift = innerWidth - outerWidth;\r\n \r\n\r\n\r\n function bindModal(triggerSelector, modalSelector, closeSelector, destroy = false) { \r\n\r\n  //конпка-подарок\r\n  let btnGift =  document.querySelector('.fixed-gift');\r\n  const trigger = document.querySelectorAll(triggerSelector);\r\n const modal = document.querySelector(modalSelector);\r\n\r\n const close = document.querySelector(closeSelector);\r\n //ф. плавного появления полосы прокрутки\r\n function fadeScroll() {\r\n setTimeout(() => {\r\n    document.body.style.marginRight = 0 +'px';\r\n    document.body.style.overflow = '';\r\n       //Отдельно для подарка-кнопки которая fixed\r\n       btnGift.style.marginRight = 0 +'px';\r\n\r\n  }, 0); // ставим 200-300 если анимация 300 - тогда не виден скачоу именно внутри модалки\r\n }\r\n\r\n  //на trigger из параметра навешиваем обработчик\r\n  //надо помнить что не все триггеры именно button а могут быть и ссылка - 'a' поэтому preventDefault\r\n  trigger.forEach(item => { \r\n  item.addEventListener('click', (e)=> { \r\n    btnPressed = true;\r\n       // очищаем показ модалки по таймеру при кликах юзера\r\n  clearTimeout(clearShowModal);\r\n    //проверяем что кликнули на элемент который имеет event событие\r\n    if(e.target) {\r\n      e.preventDefault();\r\n    }\r\n//проверяем что нужно удалить кнопку вызова - подарок\r\nif(destroy == true) {\r\n  item.remove(); // удаляем элемент кнопку подарок\r\n}\r\n\r\n//для всех модалок закрытие - здесь как дополнение - этот код закроет все а ниже откроет ту модалку что была вызывана\r\n// windows.forEach(item => {\r\n//   item.style.display = 'none';\r\n//   // });\r\n\r\n    //получаем из параметра  modal и показываем\r\n    modal.style.display = 'block';\r\n   // modal.classList.add('animated', 'fadeIn'); // плавно появится но убирается жестко\r\n  //блокируем прокрутку страницы\r\n    document.body.style.overflow = 'hidden';\r\n    document.body.style.marginRight = contentShift +'px';\r\n    //Отдельно для подарка-кнопки которая fixed\r\n    btnGift.style.marginRight = contentShift +'px';\r\n\r\n   }); \r\n });\r\n\r\n// закрываем по крестику\r\nclose.addEventListener('click', ()=> { \r\n // дополнительно закрытие всех модалок\r\n// windows.forEach(item => {\r\n//   item.style.display = 'none';\r\n \r\n// });\r\nfadeScroll(); // задержа сдвига контента при закрытии. НО т.к. d-none то нет смысла\r\n  modal.style.display = 'none';\r\n\r\n \r\n });\r\n   //закрываем по фону\r\n   modal.addEventListener('click', (e)=> { \r\n    if(e.target == modal) {\r\n      // дополнительно закрытие всех модалок\r\n  // windows.forEach(item => {\r\n  //   item.style.display = 'none';\r\n  // });\r\n  fadeScroll();\r\n  modal.style.display = 'none';\r\n    \r\n   }\r\n   });\r\n \r\n } // конец bindModal\r\n\r\n\r\n // Показываем окно с подарком при пркрутке в самый низ страницы\r\n// console.log(document.documentElement.scrollHeight); //17231\r\n// console.log(window.innerHeight); // 744\r\n// console.log(document.documentElement.scrollTop);\r\n\r\n//создадим ф. показа подарка при скроле вниз\r\nfunction openModalByScroll(selector) { \r\n  window.addEventListener('scroll',  ()=> { \r\n    //проверка на высоту свойства scrollHeight\r\n    // let scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);\r\n    //если не было кликов по кнопкакм и долистал до низа\r\n    if(btnPressed == false && document.documentElement.clientHeight + window.pageYOffset >= document.documentElement.scrollHeight   ) {\r\n    // document.querySelector(selector).style.display = 'block';\r\n//Но у Ивана вызов идет через click() который эмулирует клик по кнопке которую передали в параметре и это запускает trigger вверху который уже следит за этой кнопкой  и запускает свои действия - показ модалки и удаление кнопки подарка . Ну и ну!! \r\ndocument.querySelector(selector).click(); // клик\r\n    }\r\n    });\r\n}\r\nopenModalByScroll('.fixed-gift');\r\n\r\n\r\n   //Показываем модалку через таймер\r\n   let clearShowModal;\r\n  function showModalByTime(selector, time) { \r\n  clearShowModal = setTimeout(() => {\r\n    console.log(11);\r\n\r\n//чтобы меньше писать всем назначу переменную modal\r\n    let modal =  document.querySelector(selector);\r\n    modal.style.display = 'block';\r\n   //блокируем прокрутку страницы\r\n     document.body.style.overflow = 'hidden';\r\n     document.body.style.marginRight = contentShift +'px';\r\n    }, time);\r\n  }\r\n  //Вызываем показ модалки по таймеру\r\n  //showModalByTime('.popup-consultation', 5000); // отключил\r\n\r\n \r\n //передаем аргументы в bindModal для модалки\r\n//Вызывваем модалку по клику на кнопках - Заказать дизайн\r\n //т.к. класс popup_close есть еще и в других секциях ограничиваем видимость нужной секцией .popup-design\r\nbindModal('.button-design', '.popup-design', '.popup-design .popup-close' );\r\nbindModal('.button-consultation', '.popup-consultation', '.popup-consultation .popup-close' );\r\n\r\nbindModal('.fixed-gift', '.popup-gift', '.popup-gift .popup-close',  true);\r\n\r\n\r\n}; //конец modals\r\nexport default modals; // по умолчанию экспортируем","const pictureSize = (imgSelector)=> { // передаем селектор img\r\nconst blocks = document.querySelectorAll(imgSelector);\r\n\r\n//ф. показа фото при наведении мыши\r\nfunction showImg(block) {\r\n  const img = block.querySelector('img');\r\n  //отрежем 4 символа с конца .png и добавим \r\nimg.src = img.src.slice(0, -4) + '-1.png'\r\n//скрываем цены и размеры кроме одно класса\r\nblock.querySelectorAll('p:not(.sizes-hit)').forEach(item => {\r\n  item.style.display = 'none';\r\n});\r\n}\r\n\r\n//ф. скрытия фото при уводе мыши\r\nfunction hideImg(block) {\r\n  const img = block.querySelector('img');\r\n  //отрежем 4 символа с конца .png и добавим \r\nimg.src = img.src.slice(0, -6) + '.png'\r\n//скрываем цены и размеры кроме одно класса\r\nblock.querySelectorAll('p:not(.sizes-hit)').forEach(item => {\r\n  item.style.display = 'block';\r\n});\r\n}\r\n\r\n//обработчик mouseover\r\nblocks.forEach(item => {\r\n  item.addEventListener('mouseover', ()=> { \r\n    showImg(item);\r\n  });\r\n\r\n  item.addEventListener('mouseout', ()=> { \r\n    hideImg(item)\r\n  });\r\n});\r\n\r\n\r\n}; //\r\nexport default pictureSize;","const scrolling = (upSelector)=> {\r\n\r\n// показ якоря при прокрутке вниз\r\nconst upElem = document.querySelector(upSelector);\r\n  window.addEventListener('scroll', ()=> { \r\n   if(document.documentElement.scrollTop > window.innerHeight) {\r\n   upElem.classList.add('animated', 'fadeIn');\r\n   //также надо удалить класс\r\n   upElem.classList.remove('fadeOut');\r\n   } else {\r\n    upElem.classList.add('fadeOut');\r\n    upElem.classList.remove('fadeIn');\r\n   }\r\n  });\r\n\r\n//плавный скролл\r\n//т.к. у разных браузеров расчет расстояний разный, будем использовать два свойства и выбирать одно из них автоматом\r\n\r\n// console.log(element.scrollTop); // 1200\r\n// console.log(body.scrollTop); // 0  - почему??\r\n\r\n//Второй вариант  с requestAnimationFrame - рабочий\r\n\r\nlet links = document.querySelectorAll( '[href^=\"#\"] '); // ищет все ссылки которые начинаются с # - каретка ^ значит сначала строки \r\nlet speed = 0.3;\r\n\r\nlinks.forEach(item => {\r\n  item.addEventListener('click', function(e) { \r\n    e.preventDefault();\r\n    let widthTop = document.documentElement.scrollTop; // от верха прокрутка в момент клика\r\n    \r\n    let hash  = this.hash; // также можно получить через рег. выр.\r\n    console.log(hash); // hash - будем получать #portfolio, #up  и др.\r\n    \r\n    let toBlock = document.querySelector(hash).getBoundingClientRect().top; // если уйдет за верх браузера - будет отрицательное значение\r\n    console.log(toBlock); //querySelector(hash) - это идентификатор id - с секцией куда надо идти - #portfolio  и др. и расстояние до них - может быть отрицательное и положительное. Когда кликаю по якорю Наверх и скролл идет вверх к Шапке то получаем отрицательное значение getBoundingClientRect().top и наоборот\r\n    let start = null;\r\n\r\n    requestAnimationFrame(step); // передаем ф. которая и будет анимировать\r\n    \r\n    function step(time) {\r\n      if(start === null) { //это условие выполнится только один раз -  проверяем что в первый раз запускается анимация\r\n          start = time; // т.е. при следующем цикле итерации при анимации уже не null  \r\n      }\r\n      let progress = time - start; // time всегда новый - start вычисляется только в самом начале анимации \r\n      // рассчет кол-ва пикселей - на сколько пикселей надо сдвинуть анимацию за это время и в какую сторону (вверх\\низ). progress - сколько уже пролистано\r\n      let r  =(toBlock < 0 ? Math.max(widthTop - progress / speed, widthTop + toBlock) :  Math.min(widthTop + progress / speed, widthTop + toBlock));\r\n\r\n      //далее саммый главный код. запускаем скролл к нужным координатам\r\n    document.documentElement.scrollTo(0, r);\r\n\r\n    //Когда надо остановить анимацию\r\n    if( r!= widthTop + toBlock) { //если не дошли до нужного элемента\r\n      requestAnimationFrame(step);\r\n    } else  {\r\nlocation.hash = hash;\r\n    }\r\n\r\n    }//\r\n\r\n  });\r\n});\r\n\r\n\r\n\r\n// //Первый вариант на чистом JS\r\n// const element  = document.documentElement;\r\n// const body = document.body;\r\n// const calcScroll = ()=> {\r\n// upElem.addEventListener('click', function(e) { // нужен контекст вызова + объект событие т.к. клик по ссылке\r\n//   //нам надо получить расстояние до верха окна в момент клика по кнопке\r\n//   let scrollTop = Math.round(body.scrollTop || element.scrollTop); //Math round зачем??\r\n \r\n \r\n//  //console.log(this.hash); // получим #up - то что пишется внутри ссылки\r\n//   // проверяем что в сcылке есть hash \r\n//   if(this.hash !== '') {\r\n//     e.preventDefault();\r\n//     console.log(' Привет');\r\n//     let hashElement = document.querySelector(this.hash); //\r\n//    console.log(hashElement); \r\n//    //<header id=\"up\"  class=header>\r\n//     //узнаем сколько надо пролистать до родителя этого hash элемента\r\n// let hashElementTop = 0;\r\n\r\n//     while(hashElement.offsetParent) { //пока true - перебираем всех родителей \r\n//       hashElementTop = hashElementTop + hashElement.offsetTop;\r\n//       hashElement = hashElement.offsetParent;\r\n//            console.log(hashElement.offsetParent);\r\n//     }\r\n\r\n//   hashElementTop = Math.round(hashElementTop); // на всякий случай если дробное получим\r\n//   smoothScroll(scrollTop, hashElementTop, this.hash);\r\n//   }\r\n \r\n// });\r\n// };\r\n\r\n// const smoothScroll = (from, to, hash)=> { // в параметр from приходит статичное значение sctollTop которое не изменяется\r\n\r\n// console.log(from);\r\n// console.log(to);\r\n// console.log(hash);\r\n\r\n// let timeInterval = 1;\r\n// let prevScrollTop;\r\n// let speed;\r\n// //также надо проверить куда будет прокрутка вверх или вниз\r\n// if(to > from) {\r\n//   speed = 30; // это пиксели за единицу времени\r\n// } else {\r\n//   speed =  -30;\r\n// }\r\n\r\n// //создаем анимацию через setInterval\r\n// let move  = setInterval(() => {\r\n//   // копируем еще раз переменную чтобы знать изменения на лету\r\n//   let scrollTop = Math.round(body.scrollTop || element.scrollTop); \r\n\r\n//   if(prevScrollTop === scrollTop ||\r\n//     (to > from && scrollTop >= to) || \r\n//     (to < from && scrollTop <= to)) {// если страница дошла до нужного места\r\n\r\n// clearInterval(move);\r\n// // далее объект history???\r\n// history.replaceState(history.state, document.title, location.href.replace( /#.*$/g, \"\") + hash);\r\n\r\n//   } else {\r\n//     body.scrollTop += speed; // сработает то которое существует\r\n//     element.scrollTop += speed; // вот здесь ошибка была scrollTo\r\n//     prevScrollTop = scrollTop; // будет все время перезаписываться\r\n//   }\r\n  \r\n// }, timeInterval);\r\n// };\r\n\r\n\r\n// calcScroll();\r\n\r\n\r\n\r\n\r\n\r\n};//\r\nexport default scrolling;","import { getResource } from \"../services/requests\";\r\n\r\n// const showMoreStyles = (trigger, styles)=> { \r\n// const cards  = document.querySelectorAll(styles);\r\n// const btn  = document.querySelector(trigger);\r\n// //Будем использовать готовые анимации из animate.css\r\n// cards.forEach(item => {\r\n//   item.classList.add('animated', 'fadeInUp');\r\n// });\r\n// btn.addEventListener('click', ()=> { \r\n \r\n//   cards.forEach(item => {\r\n//     item.classList.remove('hidden-lg', 'hidden-md', 'hidden-sm', 'hidden-xs');\r\n//     item.classList.add('col-sm-3' , 'col-sm-offset-0' , 'col-xs-10' , 'col-xs-offset-1');\r\n//   });\r\n//   //скрывваем кнопку после клика\r\n//   btn.style.display = 'none';\r\n//   //btn.remove(); или совсем удалим\r\n// });\r\n\r\n//Второй вариант для json сервера\r\nconst showMoreStyles = (trigger, wrapper)=> { \r\n \r\n  const btn  = document.querySelector(trigger);\r\n\r\nbtn.addEventListener('click', function() { \r\n  //в параметр передаем путь  к json серверу \r\n  getResource('assets/db.json')\r\n  .then(res => createCards(res.styles)) // вызываем ф. с результатами от сервера res - это массив\r\n  .catch(error => console.log('error'));\r\n\r\n  // нам также надо удалить или спрятать кнопкуц после клика но так это не сделать\r\n  // this.remove() т.к. стрелочная ф. поэтому меняем на классическую ф.\r\n  this.remove();\r\n});\r\n\r\nfunction createCards(response) { // будет принимать ответ от сервера - файл db.json с массивом элементов для строительства блоков\r\n  response.forEach(({src,  title, link}) => {\r\n    //создадим шаблок карточки\r\n    let card = document.createElement('div');\r\n    //добавляем классы + классы анимации\r\n    card.classList.add('animated', 'fadeInUp', 'col-sm-3' , 'col-sm-offset-0' , 'col-xs-10' , 'col-xs-offset-1');\r\n//наполняем карточки - можно через innerHTML - более рационально. Второй вариант - через append и createElement - берем первый вариант\r\n\r\ncard.innerHTML = `\r\n<div class=\"styles-block\">\r\n  <img src=${src} alt='#'>\r\n  <h4>${title}</h4>\r\n  <a href=\"${link}\">Подробнее</a>\r\n</div>\r\n`;\r\n\r\n//добавляем карточки на страницу - через родителя row и id='styles' \r\ndocument.createElement(wrapper).appendChild(card)\r\n\r\n  });\r\n}\r\n}; //конец\r\nexport default showMoreStyles;"," //вызывать работу будем из main\r\n //переадем в параметры - слайды, направление движения ( т.к. вертик или горизонт.), кнопки вперед, назад\r\nconst sliders = (slides, dir, prev, next ) => {\r\n  let slideIndex = 1; // текущий слайд - первый\r\n  const items = document.querySelectorAll(slides);\r\n  // ф. инициализации показа\r\nfunction showSlides(n) { \r\n  if( n > items.length) {\r\n    slideIndex =1;\r\n  }\r\n  if(n <1 ) {\r\n    slideIndex = items.length;\r\n  }\r\n  items.forEach(item => { \r\n    item.classList.add('animated'); // который в animate.css animation-duration:1s;\r\n    item.style.display = 'none';\r\n   });\r\n   items[slideIndex - 1].style.display = 'block';\r\n}\r\nshowSlides(slideIndex);\r\n// ф. показа текущего слайда - вызывать будем при кликах на кнопки\r\nfunction plusSlides(n) { // в параметр будем пердавать -1 или +1 тем самым показывая след. или предыд. слайд\r\n  showSlides(slideIndex += n);\r\n}\r\n//блок обработки ошибок - для первого слайдера где нет кнопок вперед-назад\r\ntry {\r\n  const prevBtn = document.querySelector(prev);\r\n  const nextBtn = document.querySelector(next);\r\n  prevBtn.addEventListener('click', ()=> { \r\n    plusSlides( -1); // предыдущий \r\n    items[slideIndex -1].classList.remove('slideInLeft'); // предыдущее направление прокрутки вот что делает transform:translate3d(-100%,0,0);\r\n    items[slideIndex -1].classList.add('slideInRight');\r\n  });\r\n nextBtn.addEventListener('click', ()=> { \r\n    plusSlides(1); // следующий \r\n    items[slideIndex -1].classList.remove('slideInRight'); // предыдущее направление прокрутки\r\n    items[slideIndex -1].classList.add('slideInLeft');\r\n  });\r\n} catch(error) {}\r\n//Отключаем автопоказ при наведении мыши\r\nlet paused = false; // можно без значения - нужна снаружи\r\n//ф. автопоказа слайдеров\r\nfunction activateAnimation() { \r\n//настройка условия для первого слайдера  - вертикального\r\nif (dir== 'vertical') {\r\npaused = setInterval(() => { // запускаем автопоказ\r\n    plusSlides(1);\r\n    items[slideIndex -1].classList.add('slideInDown');\r\n  }, 3000);\r\n} else { // если нет dir - Значит для он не вертик. а горизонт. Также запускаем автопоказ но уже горизонтальный\r\n paused = setInterval(() => { // запускаем автопоказ\r\n    plusSlides(1);\r\n    items[slideIndex -1].classList.add('slideInLeft');\r\n  }, 3000);\r\n}\r\n}\r\n//отключил\r\n//activateAnimation(); // вызываем автоматом автопоказ\r\n//берем слайд любой и находим по нему сам слайдер родитель\r\nitems[0].parentNode.addEventListener('mouseenter', ()=> {\r\nclearInterval(paused); // остановили автопоказ\r\n});\r\n//берем слайд любой и находим по нему сам слайдер родитель\r\nitems[0].parentNode.addEventListener('mouseleave', ()=> {\r\n  //activateAnimation(); // остановили автопоказ\r\n  });\r\n\r\n  \r\n}; //конец\r\nexport default sliders;  ","//Здесь будем создавать и экспортировать запросы для модуля Forms  и для showMoreStyles для связи с json сервером\r\n\r\n// для Forms т.к. запрос асинхронный и сервер может долго отвечать - async/await\r\nconst postData = async (url, data)=> {\r\n\r\n  let res = await fetch(url, { // ждать должен\r\n    method: \"POST\", // вот где ошибка была!!! надо \"POST\"  а не POST\r\n    body: data,\r\n    //для formData заголовок не надо добавлять\r\n  });\r\n  return await res.text();\r\n  };\r\n\r\n  //воторой запрос для db.json уже с GET запросом\r\nconst getResource = async (url)=> {\r\n\r\n  let res = await fetch(url);\r\n\r\n  //добавим проверку при отправке - если не прошло получение 404, 505 и т.д.\r\n  if(!res.ok) {\r\n    throw new Error (` Could not fetch ${url}, status ${res.status} `);\r\n  }\r\n  //уже отдаем в json формате\r\n  return await res.json();\r\n  };\r\n\r\n  //Экспортируем эти две ф.\r\n  export  {postData, getResource }"],"sourceRoot":""}